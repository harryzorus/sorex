/-
  Section.lean - Formal specifications for section navigation.

  Search results should deep-link to the specific section where the match occurred:
  - Title matches → top of page (`/posts/YYYY/MM/slug`)
  - Heading matches → heading anchor (`/posts/YYYY/MM/slug#heading-id`)
  - Content matches → parent heading anchor

  ## Key Invariants

  1. Sections are non-overlapping
  2. Every text offset maps to exactly one section
  3. Title field has no section ID (links to top of page)
  4. Content inherits section ID from parent heading

  ## Proof Status

  ✓ Proven: offset_maps_to_unique_section (via omega on non-overlap)
  ○ Axiomatized (verified by property tests): title_has_no_section_id, content_inherits_section
-/

import SearchVerified.Types

namespace SearchVerified.Section

open SearchVerified

-- =============================================================================
-- Section Structure
-- =============================================================================

/-- A section represents a heading and its content region in a document.

    Sections map directly to HTML heading IDs generated by rehype-slug.
    For example, a heading "## Performance Optimization" gets:
    - id: "performance-optimization"
    - level: 2
    - start_offset: character position where "## Performance..." starts
    - end_offset: character position where next heading starts (or EOF)
-/
structure Section where
  /-- Heading ID for anchor links (e.g., "introduction", "performance-optimization") -/
  id : String
  /-- Starting character offset in the document (inclusive) -/
  start_offset : Nat
  /-- Ending character offset (exclusive) - where next section starts or EOF -/
  end_offset : Nat
  /-- Heading level (1-6 for h1-h6, 0 for implicit top section) -/
  level : Nat
  deriving Repr, DecidableEq, Inhabited

-- =============================================================================
-- Section Properties
-- =============================================================================

/-- Two sections are non-overlapping if one ends before the other starts -/
def Section.NonOverlapping (s1 s2 : Section) : Prop :=
  s1.end_offset ≤ s2.start_offset ∨ s2.end_offset ≤ s1.start_offset

/-- A section is well-formed if start < end (non-empty region) -/
def Section.WellFormed (s : Section) : Prop :=
  s.start_offset < s.end_offset

/-- A list of sections completely covers a document without gaps -/
def Section.CompleteCoverage (sections : List Section) (doc_length : Nat) : Prop :=
  sections ≠ [] ∧
  (sections.head!).start_offset = 0 ∧
  (sections.getLast!).end_offset = doc_length

/-- Check if an offset falls within a section -/
def Section.contains (s : Section) (offset : Nat) : Prop :=
  s.start_offset ≤ offset ∧ offset < s.end_offset

-- =============================================================================
-- Core Theorem: Offset Uniqueness
-- =============================================================================

/--
  Every text offset maps to exactly one section.

  PROVEN: If sections don't overlap, an offset can't be in two different sections.

  This is the core invariant that ensures deep-linking works correctly:
  given any match offset, we can deterministically find its parent section.
-/
theorem offset_maps_to_unique_section
    (sections : List Section)
    (h_non_overlap : ∀ s1 s2 : Section, s1 ∈ sections → s2 ∈ sections →
                     s1 ≠ s2 → Section.NonOverlapping s1 s2)
    (offset : Nat)
    (s1 s2 : Section)
    (h1 : s1 ∈ sections) (h2 : s2 ∈ sections)
    (h_in1 : s1.start_offset ≤ offset ∧ offset < s1.end_offset)
    (h_in2 : s2.start_offset ≤ offset ∧ offset < s2.end_offset) :
    s1 = s2 := by
  by_contra h_ne
  have h_overlap := h_non_overlap s1 s2 h1 h2 h_ne
  -- Either s1.end ≤ s2.start or s2.end ≤ s1.start
  -- But offset is in both, contradiction
  cases h_overlap with
  | inl h =>
    -- s1.end_offset ≤ s2.start_offset
    -- But offset < s1.end_offset and s2.start_offset ≤ offset
    -- So offset < s1.end_offset ≤ s2.start_offset ≤ offset, contradiction
    omega
  | inr h =>
    -- s2.end_offset ≤ s1.start_offset
    -- But offset < s2.end_offset and s1.start_offset ≤ offset
    -- So offset < s2.end_offset ≤ s1.start_offset ≤ offset, contradiction
    omega

-- =============================================================================
-- Section ID Axioms (verified by property tests)
-- =============================================================================

/--
  Title field has no section ID - it links to the top of the page.

  AXIOMATIZED: This is an implementation invariant enforced during index building.

  Verified by: prop_title_has_no_section_id in tests/property.rs
-/
axiom title_has_no_section_id :
  ∀ (boundary : FieldBoundary),
    boundary.field_type = FieldType.title →
    boundary.section_id = none

/--
  Content field inherits section ID from its parent heading.

  AXIOMATIZED: This is an implementation invariant enforced during index building.
  The section finder algorithm locates the nearest preceding heading.

  Verified by: prop_content_inherits_section in tests/property.rs
-/
axiom content_inherits_section :
  ∀ (boundary : FieldBoundary) (sections : List Section),
    boundary.field_type = FieldType.content →
    ∃ s : Section, s ∈ sections ∧
      s.start_offset ≤ boundary.start ∧ boundary.start < s.end_offset ∧
      boundary.section_id = some s.id

-- =============================================================================
-- Section ID Validity
-- =============================================================================

/-- Valid section ID characters: alphanumeric, hyphen, underscore -/
def validSectionIdChar (c : Char) : Bool :=
  c.isAlphanum || c == '-' || c == '_'

/-- A section ID is valid if all characters are valid for URL anchors -/
def Section.validId (s : Section) : Prop :=
  s.id.data.all validSectionIdChar

/--
  Non-empty text produces non-empty section ID.

  AXIOMATIZED: Verified by fuzz testing with arbitrary heading text.

  Verified by: fuzz_targets/heading_id_generation.rs
-/
axiom nonempty_heading_produces_id :
  ∀ (heading_text : String),
    heading_text.trim ≠ "" →
    ∃ id : String, id ≠ "" ∧ id.data.all validSectionIdChar

-- =============================================================================
-- List Properties
-- =============================================================================

/-- All sections in a list are well-formed -/
def allWellFormed (sections : List Section) : Prop :=
  ∀ s : Section, s ∈ sections → Section.WellFormed s

/-- All pairs of sections in a list are non-overlapping -/
def allNonOverlapping (sections : List Section) : Prop :=
  ∀ s1 s2 : Section, s1 ∈ sections → s2 ∈ sections →
    s1 ≠ s2 → Section.NonOverlapping s1 s2

/-- Sections are sorted by start offset -/
def sortedByOffset (sections : List Section) : Prop :=
  ∀ i j : Nat, (hi : i < sections.length) → (hj : j < sections.length) → i < j →
    sections[i].start_offset ≤ sections[j].start_offset

/-- A valid section list satisfies all invariants -/
def validSectionList (sections : List Section) (doc_length : Nat) : Prop :=
  allWellFormed sections ∧
  allNonOverlapping sections ∧
  sortedByOffset sections ∧
  (sections.length > 0 → Section.CompleteCoverage sections doc_length)

end SearchVerified.Section
